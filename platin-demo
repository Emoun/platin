#!/usr/bin/env ruby
#
# PSK demo driver
#

require 'yaml'
require 'ostruct'
require 'optparse'

# Build directory settings
LEVEL="../.."
BUILDDIR="build"

# Default External commands
CMD_SWEET="" # set to enable analysis with SWEET
CMD_ALF_LLC="alf-llc"
CMD_AIT="a3patmos"

# LLVM/Patmos commands
PATMOS_LLVM_LD_BIN="patmos-llvm-ld"
PATMOS_LD_BIN="patmos-ld"

($stderr.puts "Neccessary tool #{PATMOS_LLVM_LD_BIN} not found using 'which'";exit 1) if `which patmos-llvm-ld`.empty?
PATMOS_PATH=File.join(File.dirname(`which patmos-ld`),"..")

# local build commands
LLC="%<bin>s -march=patmos -mforce-block-labels -mpatmos-serialize=%<pml>s -mpatmos-preemit-bitcode=%<bc>s -filetype=obj -o %<of>s %<if>s"

# cannot use CLANG inside build dir (missing libs)
PATMOS_CLANG="%<patmos>s/bin/patmos-clang -Xllc --serialize=%<pml>s -o %<of>s %<if>s" 

# patmos commands
PATMOS_PASIM="%<patmos>s/bin/pasim -q --debug 1 -b %<if>s 2>%<tracefile>s"
PATMOS_LLVM_LD="%<patmos>s/bin/#{PATMOS_LLVM_LD_BIN} -emit-llvm -L%<patmos>s/patmos-unknown-elf/lib/ -b %<of>s %<patmos>s/patmos-unknown-elf/lib/crt0.o %<if>s -internalize-public-api-file=%<patmos>s/patmos-unknown-elf/lib/libcsyms.lst %<patmos>s/patmos-unknown-elf/lib/libcsyms.o -lc -lpatmos -internalize-public-api-file=%<patmos>s/patmos-unknown-elf/lib/librtsfsyms.lst %<patmos>s/patmos-unknown-elf/lib/librtsfsyms.o -lrtsf -internalize-public-api-file=%<patmos>s/patmos-unknown-elf/lib/librtsyms.lst %<patmos>s/patmos-unknown-elf/lib/librtsyms.o -lrt -internalize-public-api-list=_start,main -no-script"
PATMOS_LD="%<patmos>s/bin/#{PATMOS_LD_BIN} -o %<of>s -nostdlib -static --defsym _uart_status_base=0xF0000000 --defsym _uart_data_base=0xF0000004 --defsym _shadow_stack_base=0x4000000 --defsym _shadow_stack_base=0x4000000 --defsym _stack_cache_base=0x3000000 --defsym __heap_end=0x2000000 --defsym __heap_start=end %<if>s"
# platin tools
MERGE="%<platin>s/psk merge -o %<of>s %<ifs>s"
FF2PML="%<platin>s/psk ff2pml -i %<if>s -o %<of>s %<ff>s"
EXTRACT_SYMBOLS="%<platin>s/psk extract-symbols -i %<if>s -o %<of>s %<elf>s"
ANALYZE_TRACE="%<platin>s/psk analyze-trace -i %<if>s -o %<of>s %<elf>s"
WCA="%<platin>s/psk wca -i %<if>s -o %<of>s"
DEMO_EQUATIONS="%<platin>s/psk demo-equations %<if>s"
PML2AIS="%<platin>s/psk pml2ais --header --ais %<ais>s -a %<apx>s -b %<elf>s -e main -r %<report>s -x %<result>s %<if>s"
AIT2PML="%<platin>s/psk ait2pml -i %<if>s -o %<of>s %<xml>s"

# external tools
IGNORED_DEFINITIONS="_start,_exit,exit,abort,_sbrk.heap_ptr,__adddf3,__addsf3,__divdf3,__divsf3,__eqdf2,__eqsf2,__extendsfdf2,__fixdfdi,__fixdfsi,__fixsfdi,__fixsfsi,__fixunsdfdi,__fixunsdfsi,__fixunssfdi,__fixunssfsi,__floatdidf,__floatdisf,__floatsidf,__floatsisf,__floatundidf,__floatundisf,__floatunsidf,__floatunsisf,__gedf2,__gesf2,__gtdf2,__gtsf2,__ledf2,__lesf2,__ltdf2,__ltsf2,memcpy,memmove,memset,__muldf3,__mulsf3,__nedf2,__nesf2,__subdf3,__subsf3,__truncdfsf2,__unorddf2,__unordsf2"
BC2ALF="%<bin>s -march=alf -alf-standalone -alf-ignore-definitions=#{IGNORED_DEFINITIONS} -alf-memory-areas=0x0000-0xffff -o=%<of>s %<if>s"
ALF2FF="%<bin>s -i=%<if>s func=main -ae ffg=ub vola=t -f co o=%<of>s"
AIT="%<bin>s -b %<apx>s"

class Demo
  attr_accessor :outdir, :logfile
  attr_writer :level, :builddir, :binprefix
  # external commands
  attr_accessor :cmd_sweet, :cmd_alf_llc, :cmd_ait, :steps
  def initialize
    @step = 1
    @steps = 1..1024
    @outdir,@logfile=".","log"
    @level,@builddir,@binprefix=LEVEL,BUILDDIR,""
    @cmd_sweet,@cmd_alf_llc, @cmd_ait = CMD_SWEET, CMD_ALF_LLC, CMD_AIT
  end
  def run_patmos(cmd, arghash)
    arghash[:patmos] = PATMOS_PATH
    run(cmd, arghash)
  end
  def run_build(cmd, bin, arghash)
    arghash[:bin] = File.join(File.dirname(__FILE__),@level,@builddir,"bin","#{@binprefix}#{bin}")
    run(cmd, arghash)
  end
  def run_platin(cmd, arghash)
    arghash[:platin] = File.join(File.dirname(__FILE__))
    run(cmd, arghash)
  end
  # running
  def run(cmdstring,arghash)
    cmd = cmdstring % arghash
    cmd = cmd + " --verbose" if arghash[:verbose]
    system("echo '***' #{cmd} >>#{@logfile}")
    cmdstring = cmd
    cmdstring = "#{cmdstring} >>#{@logfile} 2>&1" unless arghash[:noredirect]
    if system(cmdstring)
      $stderr.puts "#{GREEN }[SUCCESS] #{CYAN}#{cmd}#{DEFCOLOR}"
    else
      $stderr.puts "#{RED   }[FAILED!] #{cmd}#{DEFCOLOR}"
      $stderr.puts "Consult log file: #{@logfile}"
      exit 1
    end
  end
  # demo step
  def step(msg)
    if @steps.cover?(@step)
      info("[#{@step}] #{msg}") ; 
      yield 
    else
      info("[#{@step}] #{msg} (Skipped)") ;
    end
    @step += 1
  end

  # output
  def Demo.escape_seq(c) ;"\x1b[#{c}m"; end
  BLACK,RED,GREEN,YELLOW,BLUE,MAGENTA,CYAN,WHITE=(0..7).map {|c| escape_seq(c+30)}
  DEFCOLOR=escape_seq(39)
  def sep; $stderr.puts("-"*78); end
  def info(msg)
    $stderr.puts   "[ INFO  ] #{msg}"
  end

end

def die(msg) ; $stderr.puts msg ; exit 1 ; end

# Standard option parser
demo = Demo.new
parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [OPTIONS] program.bc"
  opts.on("-O", "--outdir DIR", "directory for output files (default: .)") { |dir| demo.outdir = dir }
  opts.on("","--steps N[..M]","execute step N (to M) only") { |nm|
    n,m = nm.split(/\.\./).map { |s| s.to_i }
    demo.steps = if m then n..m else n..n end
  }
  opts.on("", "--alf-llc-command CMD", "path to alf-llc executable") { |cmd| demo.cmd_alf_llc=cmd }
  opts.on("", "--sweet-command CMD", "path to SWEET executable") { |cmd| demo.cmd_sweet=cmd }
  opts.on("", "--ait-command CMD","path to a3patmos executable") { |cmd| demo.cmd_ait=cmd }
  opts.on_tail("-h", "--help", "Show this message") { $stderr.puts opts; exit 0 }
end.parse!

die "Wrong number of arguments. Try --help" unless ARGV.length==1

outdir = File.expand_path demo.outdir
bc,mod=ARGV[0],ARGV[0].sub(/\.[^\.]*$/,'')
file = Proc.new { |suffix| File.join(outdir, "#{File.basename(mod)}.#{suffix}") }

if ! File.exist?(bc)
  die "File #{bc} does not exist" 
elsif bc == file.call("bc")
  die "Outdir should be different from source directory"
end

demo.logfile = file.call("log")
pml = file.call("elf.pml")
system("echo PSK-DEMO > #{demo.logfile}")

demo.info("================")
demo.info("   PSK Demo     ")
demo.info("================")
demo.info("Takes an optimized bitcode file (not yet linked with libc)")
demo.info("and performs various tasks using the PSK tool chain")
demo.sep

demo.step("Link application with patmos-newlib (bitcode level)") do
  demo.run_patmos(PATMOS_LLVM_LD, :if=>bc, :of=> file.call("bc"))
end

demo.step("Run backend, and export LLVM-internal information to YML") do
  demo.run_build(LLC, "llc", :if => file.call("bc"), :bc => file.call("elf.bc"), :pml => pml, :of=>file.call("elf.o"))
end

demo.step("Link ELF binary") do
  demo.run_patmos(PATMOS_LD, :if=>file.call("elf.o"), :of=>file.call("elf"))
end

demo.step("Merge Stream of PML documents (optional)") do
  demo.run_platin(MERGE, :ifs => "#{pml}", :of => pml)
end

demo.step("Extract addresses from ELF binary") do
  demo.run_platin(EXTRACT_SYMBOLS, :if => pml, :of => pml, :elf => file.call("elf"))
end

demo.step("Analyze trace generated using pasim") do
  demo.run_platin(ANALYZE_TRACE, :if=> pml, :of => pml, :elf => file.call("elf"),
               :noredirect => true)
end


unless `which #{demo.cmd_sweet}`.strip.empty?
  demo.step("Generate SWEET Flow Facts") do
    demo.run(BC2ALF, :bin => demo.cmd_alf_llc, :if => file.call("elf.bc"), :of => file.call("alf"))
    demo.run(ALF2FF, :bin => demo.cmd_sweet,   :if => file.call("alf"), :of => file.call("ff"))
  end
  demo.step("Add SWEET Flow Facts to PML file") do
    demo.run_platin(FF2PML, :if => pml, :of => pml, :ff => file.call("ff"))
  end
end

demo.step("Display control-flow relation graph equations and flow fact inequalities") do
  demo.run_platin(DEMO_EQUATIONS, :if => pml) #,:noredirect => true)
end

demo.step("Run platin worst-case estimation") do
  demo.run_platin(WCA, :if => pml, :of => pml)
end

demo.step("Export information to aiT's ais format") do
  demo.run_platin(PML2AIS, :if => pml, :ais => file.call("ais"),
               :apx => file.call("apx"), :elf => file.call("elf"),
               :report => file.call("report"), :result => file.call("xml"))
end

unless `which #{demo.cmd_ait}`.empty?

  demo.step("Run aiT") do
    demo.run(AIT, :bin => demo.cmd_ait, :apx => file.call("apx"))
    demo.info("aiT results: (report is in #{file.call("report")})")
  end
  demo.step("Import aiT results") do
    demo.run_platin(AIT2PML, :if => pml, :of => pml, :xml => file.call("xml"))
  end

end

demo.step("Display Results") do
  require 'yaml'
  YAML::load(File.read(pml))["timing"].each { |t| puts YAML::dump(t) }
end

