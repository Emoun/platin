#
# platin tool set
#
# Architecture-specific stuff, Configuration of the execution platform
require 'core/pmlbase'
module PML

# architectures
class Architecture
  @@register = {}
  def Architecture.register(archname,klass)
    die("architecture #{archname} already registered to #{@@register[archname]}") if @@register[archname]
    @@register[archname] = klass
  end
  def Architecture.simulator_options(opts)
    opts.on("--trace-file FILE", "FILE generated by architecture simulator") { |f| opts.options.trace_file = f }
    @@register.each { |arch,klass|
      klass.simulator_options(opts)
    }
  end
  def Architecture.from_triple(triple)
    archname = triple.first
    die("unknown architecture #{triple} (#{@@register})") unless @@register[archname]
    @@register[archname].new(triple)
  end
end


# configuration of the execution platform (memory areas, timing, etc.)
class MachineConfig < PMLObject
  ##
  # :attr_reader: memory_areas
  #
  # list of memory area descriptions
  # * YAML key: +memory-areas+
  # * Type: [ -> MemoryArea ]
  attr_reader :memory_areas

  ##
  # :attr_reader: caches
  #
  # list of cache configurations
  # * YAML key: +caches+
  # * Type: [ -> CacheConfig ]
  attr_reader :caches

  def initialize(memory_areas, caches, data)
    @memory_areas, @caches = memory_areas, caches
    set_yaml_repr(data)
  end

  def MachineConfig.from_pml(ctx, data)
    MachineConfig.new(
      data['memory-areas'] ? MemoryAreaList.from_pml(ctx, data['memory-areas']) : nil,
      data['caches'] ? CacheConfigList.from_pml(ctx, data['caches']) : nil,
      data)
  end
  def to_pml
    { "memory-areas" => memory_areas.to_pml,
      "caches" => caches.to_pml
    }.delete_if { |k,v| v.nil? }
  end
end

# list of cache configurations
class CacheConfig < PMLObject
  ##
  # :attr_reader: name
  #
  # unique name of the cache
  # * YAML key: +name+
  # * Type: <tt>str</tt>
  attr_reader :name

  ##
  # :attr_reader: type
  #
  # type of the cache
  # * YAML key: +type+
  # * Type: <tt>"standard" | "method-cache" | "stack-cache"</tt>
  attr_reader :type

  ##
  # :attr_reader: policy
  #
  # replacement policy
  # * YAML key: +policy+
  # * Type: <tt>str</tt>
  attr_reader :policy

  ##
  # :attr_reader: associativity
  #
  # associativity of the cache
  # * YAML key: +associativity+
  # * Type: <tt>int</tt>
  attr_reader :associativity

  ##
  # :attr_reader: line_size
  #
  # size of a cache line
  # * YAML key: +line-size+
  # * Type: <tt>int</tt>
  attr_reader :line_size

  ##
  # :attr_reader: size
  #
  # size of the cache in bytes
  # * YAML key: +size+
  # * Type: <tt>int</tt>
  attr_reader :size

  def initialize(name, type, policy, associativity, line_size, size, data = nil)
    @name, @type, @policy, @associativity, @line_size, @size =
      name, type, policy, associativity, line_size, size
    set_yaml_repr(data)
  end

  def CacheConfig.from_pml(ctx, data)
    CacheConfig.new(
      data['name'],
      data['type'],
      data['policy'],
      data['associativity'],
      data['line-size'],
      data['size'],
      data)
  end
  def to_pml
    { "name" => name,
      "type" => type,
      "policy" => policy,
      "associativity" => associativity,
      "line-size" => line_size,
      "size" => size
    }.delete_if { |k,v| v.nil? }
  end
end # class CacheConfig

# list of memory area descriptions
class MemoryArea < PMLObject
  ##
  # :attr_reader: name
  #
  # unique name of the memory area
  # * YAML key: +name+
  # * Type: <tt>str</tt>
  attr_reader :name

  ##
  # :attr_reader: type
  #
  # type / address space
  # * YAML key: +type+
  # * Type: <tt>"code" | "data" | "scratchpad"</tt>
  attr_reader :type

  ##
  # :attr_reader: cache
  #
  # name of the cache configured for this memory area (possibly bypassed)
  # * YAML key: +cache+
  # * Type: <tt>str</tt>
  attr_reader :cache

  ##
  # :attr_reader: address_range
  #
  # * YAML key: +address-range+
  # * Type: -> ValueRange
  attr_reader :address_range

  ##
  # :attr_reader: access_timing
  #
  # time to access memory area in cycles
  # * YAML key: +access-timing+
  # * Type: <tt>{load-word: int, load-line: int, load-line-burst: int}</tt>
  attr_reader :access_timing

  def initialize(name, type, cache, address_range, access_timing, data = nil)
    @name, @type, @cache, @address_range, @access_timing =
      name, type, cache, address_range, access_timing
    set_yaml_repr(data)
  end

  def MemoryArea.from_pml(ctx, data)
    MemoryArea.new(
      data['name'],
      data['type'],
      data['cache'],
      data['address-range'] ? ValueRange.from_pml(ctx, data['address-range']) : nil,
      data['access-timing'],
      data)
  end
  def to_pml
    { "name" => name,
      "type" => type,
      "cache" => cache,
      "address-range" => address_range.to_pml,
      "access-timing" => access_timing
    }.delete_if { |k,v| v.nil? }
  end
end # class MemoryArea

end # module PML

require 'arch/patmos'
require 'arch/arm'

