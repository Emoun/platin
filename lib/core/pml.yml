type:      map
mapping:
  "format":
    type: str
    required: yes
    desc: "PML format version ('pml-0.2')"
  "triple":
    type: str
    desc: "LLVM target triple (e.g., patmos-unknown-unknown-elf)"
  "machine-functions": &funlist
    type: seq
    desc: "list of functions"
    sequence:
      - &function
        type: map
        desc: "function description"
        mapping:
          "name":
            type: scalar
            required: yes
            unique: yes
            desc: "unique name of the function"
          "level": &level
            type: str
            enum: [bitcode,machinecode]
            required: yes
            desc: "representation level"
          "mapsto":
            type: scalar
            desc: "corresponding function on the next higher-level representation (if any)"
          "hash":
            type: scalar
            desc: "checksum characterizing the function"
          "arguments":
            type: seq
            desc: "the function's formal arguments"
            sequence:
              - &argument
                type: map
                mapping:
                  "index":
                    type: int
                    unique: true
                    desc: "index of the argument"
                  "name":
                    type: str
                    unique: true
                    desc: "name of the argument"
                  "registers":
                    type: seq
                    desc: "registers assigned to the formal argument"
                    sequence:
                      - &register
                        type: str
          "blocks":
            type: seq
            desc: "basic blocks of the function"
            sequence:
              - &block
                type: map
                mapping:
                  "name":
                    type: scalar
                    required: yes
                    unique: yes
                    desc: "name of the basic block (unique within the function)"
                  "mapsto":
                    type: scalar
                    desc: "corresponding block on the high-level representation (if any)"
                  "address":
                    type: int
                    desc: "address of the block in the linked binary"
                  "successors": &namelist
                    type: seq
                    desc: "list of basic blocks"
                    sequence:
                      -
                        type: scalar
                        desc: "name of the referenced basic block"
                  "predecessors": *namelist
                  "loops": *namelist
                  "instructions":
                    type: seq
                    desc: "list of the basic block's instructions"
                    sequence:
                      - &instruction
                        type: map
                        mapping:
                          "index":
                             type: int
                             required: yes
                             unique: yes
                             desc: "index of the instruction in the block's instruction list"
                          "opcode":
                             type: scalar
                             desc: "scalar characterizing the instruction's type"
                          "branch-type":
                             type: str
                             enum: [unconditional, conditional, call, return, indirect, any]
                             desc: "the kind of branch this instruction realizes (if any)"
                          "branch-targets": *namelist
                          "branch-delay-slots":
                             type: int
                          "callees": *namelist
                          "size":
                             type: int
                             desc: "size of the instruction in the binary"
                          "address":
                             type: int
                             desc: "address of the instruction in the linked binary"
  "bitcode-functions": *funlist
  "relation-graphs":
    type: seq
    sequence:
      - &rglist
        type: map
        mapping:
          "src": &rgscope
            type: map
            required: yes
            mapping:
              "function":
                 type: scalar
              "level": *level
          "dst": *rgscope
          "nodes":
            type: seq
            sequence:
              - &rgnode
                type: map
                mapping:
                  "name":
                    type: int
                    required: yes
                    unique: yes
                  "type":
                    type: str
                    required: yes
                  "src-block":
                    type: scalar
                  "dst-block":
                    type: scalar
                  "src-successors": &rgnodelist
                    type: seq
                    sequence:
                      -
                        type: scalar
                  "dst-successors": *rgnodelist
          "status":
            type: str
            enum: [valid,corrected,invalid]
  "valuefacts":
    type: seq
    sequence:
      - &valuefact
        type: map
        desc: >-
          information on the possible value of variables
          at a certain point in the program
        mapping:
          "origin":
            type: str
          "level": *level
          "variable":
            type: str
            desc: >-
              description of the variable this fact refers to
              mem-address-read ... memory address the instruction reads from
              mem-address-write ... memory address the instruction writes to
          "width":
            type: int
          "values":
            type: seq
            sequence:
              -
                type: map
                mapping:
                  "min":
                    type: int
                  "max":
                    type: int
          "program-point": &program-point
            type: map
            mapping:
              "function":
                type: scalar
              "block":
                type: scalar
              "instruction":
                 type: scalar
              "edgesource":
                  type: any
                  desc: "TODO"
              "edgetarget":
                  type: any
                  desc: "TODO"
              "context": &context
                type: seq
                sequence:
                  - &contextentry
                    type: map
                    mapping:
                      "callsite":
                        desc: >-
                          qualified name of the callsite (call context entry)
                        type: scalar
                      "loop":
                        desc: >-
                          qualified name of the loop header (loop context entry)
                        type: scalar
                      "step":
                        desc: >-
                          loop step (context applies to all iterations of the form (offest + k step))
                        type: scalar
                      "offset":
                        type: scalar
  "flowfacts":
    type: seq
    sequence:
      - &flowfact
        type: map
        desc: >-
          linear flow constraint of the form
          (variable-lhs) <> (constant-rhs)
        mapping:
          "origin":
            type: str
            desc: "the source this flow fact originated from"
          "level": *level
          "classification":
            type: any
            desc: "DEPRECATED"
          "scope": &scope
            type: map
            desc: >-
              the flow fact applies to every execution of the given
              function or loop (in the specified context)
            mapping: &scoperef
              "function":
                type: scalar
              "loop":
                type: scalar
              "context": *context
          "lhs":
            type: seq
            desc: >-
              variable left-hand side of the constraint;
              sum of program points multiplied by a constant coefficient
            sequence:
              - &term
                type: map
                mapping:
                  "factor":
                    type: int
                  "program-point": *program-point
          "op":
            type: str
            desc: >-
              comparison operator of the constraint (<= or =)
            enum: ["less-equal", "equal"]
          "rhs":
            desc: >-
              constant right-hand side of the constraint
              either an integer (non-symbolic constant)
              or a string representing a symbolic constant
            type: scalar
  "timing":
    type: seq
    sequence:
      - &tentry
        type: map
        mapping:
          "level": *level
          "origin":
            type: scalar
          "scope": *scope
          "cycles":
            required: true
            desc: "maximum execution time of the scope"
            type: int
          "profile":
            type: seq
            desc: "worst-case execution time profile"
            sequence:
              -
                type: map
                mapping:
                  "reference": *program-point
                  "cycles":
                    type: int
                    desc: "maximum execution time of the block in cycles (depends on the context)"
                  "wcet_contribution":
                    type: int
                    desc: "cycles contributed to WCET"
                  "wcet_frequency":
                    type: int
                    desc: "frequency on the worst-case path"
                  "criticality":
                    type: float
                    desc: "characterization of the block's influence on the worst-case execution time"